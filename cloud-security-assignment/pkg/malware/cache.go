package malware

import (
	"context"
	"log"
	"net/http"
	"sync"
	"time"
)

type Cache struct {
	cfg    CacheConfig
	client *http.Client

	mu        sync.RWMutex
	data      MalwareList
	expiresAt time.Time
	backoff   time.Duration
	lastErr   error
}

func NewCache(cfg CacheConfig) *Cache {
	return &Cache{
		cfg:    cfg,
		client: &http.Client{Timeout: 10 * time.Second},
	}
}

func (c *Cache) GetList(ctx context.Context) (MalwareList, error) {
	now := time.Now()

	c.mu.RLock()
	data := c.data
	exp := c.expiresAt
	err := c.lastErr
	c.mu.RUnlock()

	if data != nil && now.Before(exp) {
		return data, nil
	}

	// Fire-and-forget refresh if expired but we still have some data
	if data != nil && now.After(exp) {
		go c.refresh(context.Background())
		return data, nil
	}

	// No data yet; must fetch synchronously
	if data == nil {
		if err := c.refresh(ctx); err != nil {
			if c.cfg.FailClosed {
				return nil, err
			}
			log.Printf("[malware-cache] error fetching list (fail-open): %v", err)
			return MalwareList{}, nil
		}
		c.mu.RLock()
		defer c.mu.RUnlock()
		return c.data, c.lastErr
	}

	// data is nil but not expired? should not happen
	if err != nil && c.cfg.FailClosed {
		return nil, err
	}

	return MalwareList{}, nil
}

func (c *Cache) refresh(ctx context.Context) error {
	c.mu.RLock()
	backoff := c.backoff
	c.mu.RUnlock()

	if backoff > 0 {
		log.Printf("[malware-cache] backing off for %s before refresh", backoff)
		t := time.NewTimer(backoff)
		select {
		case <-t.C:
		case <-ctx.Done():
			t.Stop()
			return ctx.Err()
		}
	}

	list, err := FetchMalwareList(c.client, c.cfg.URL)

	c.mu.Lock()
	defer c.mu.Unlock()

	if err != nil {
		log.Printf("[malware-cache] refresh failed: %v", err)
		c.lastErr = err
		// Exponential backoff
		if c.backoff == 0 {
			c.backoff = time.Minute
		} else {
			c.backoff *= 2
		}
		if c.backoff > c.cfg.BackoffMax {
			c.backoff = c.cfg.BackoffMax
		}
		return err
	}

	c.data = list
	c.expiresAt = time.Now().Add(c.cfg.TTL)
	c.backoff = 0
	c.lastErr = nil
	log.Printf("[malware-cache] refreshed malware list: %d entries", len(list))
	return nil
}
