package malware

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	semver "github.com/Masterminds/semver/v3"
)

type MalwareEntry struct {
	PackageName string `json:"package_name"`
	VersionExpr string `json:"version"`
	Reason      string `json:"reason"`
}

type MalwareList []MalwareEntry

func (e MalwareEntry) Matches(pkgName, pkgVersion string) bool {
	if e.PackageName != pkgName {
		return false
	}

	// "*" means all versions are blocked
	if e.VersionExpr == "*" {
		return true
	}

	// Try semver constraint
	if c, err := semver.NewConstraint(e.VersionExpr); err == nil {
		if v, err := semver.NewVersion(pkgVersion); err == nil {
			return c.Check(v)
		}
	}

	// Fallback to exact string match
	return e.VersionExpr == pkgVersion
}

func FetchMalwareList(client *http.Client, url string) (MalwareList, error) {
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 300 {
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))
		return nil, fmt.Errorf("malware fetch failed: %s: %s", resp.Status, string(body))
	}

	var list MalwareList
	if err := json.NewDecoder(resp.Body).Decode(&list); err != nil {
		return nil, err
	}
	return list, nil
}

type CacheConfig struct {
	URL        string
	TTL        time.Duration
	BackoffMax time.Duration
	FailClosed bool
}
